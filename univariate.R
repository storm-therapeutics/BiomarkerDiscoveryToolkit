## Functions for biomarker discovery (e.g. for drug sensitivity in cell lines)
## Here: univariate analyses (considering e.g. one gene at a time)

source("correlation.R")

#' Filter numeric features by applying a minimum threshold
#'
#' Features (i.e. columns in `data`) with values below the threshold in too many samples (rows) are removed.
#'
#' @param data Data matrix to be filtered
#' @param threshold Threshold value
#' @param fraction Fraction of samples that must pass the treshold (0: one sample, 1: all samples)
#' @return Data matrix after filtering
filter.threshold <- function(data, threshold=1, fraction=1) {
  min.samples <- ceiling(nrow(data) * fraction)
  min.samples <- min(max(1, min.samples), nrow(data)) # must be between 1 and number of samples
  pass.count <- apply(data, 2, function(col) sum(col >= threshold, na.rm=TRUE))
  data[, pass.count >= min.samples]
}


#' Filter a response vector and data matrix to contain common samples
#'
#' Only samples that are common between `names(responses)` and `rownames(data)` are kept.
#'
#' @param responses Named vector
#' @param data Named matrix
#' @return List containing responses and data after filtering
intersect.samples <- function(responses, data) {
  inter <- intersect(names(responses), rownames(data))
  if (length(inter) == 0) stop("No overlapping samples between `responses` and `data`")
  list(responses=responses[inter], data=data[inter, ])
}


#' Generate a scatter plot with annotations
#'
#' The values in `response` are plotted against the values in `data` (`feature` column if `data` is a matrix).
#' `feature` is used as plot title.
#' A subtitle is generated from `cor.pvs`, including Pearson/Spearman correlation coefficients and the first p-value (if available).
#'
#' @param feature Name of the feature shown (e.g. gene)
#' @param responses Response values (shown on y axis)
#' @param data Feature values (vector or matrix; shown on x axis)
#' @param cor.pvs Numeric vector of correlation coefficients (and p-values, optionally)
#' @param xlab X axis label
#' @param ylab Y axis label
plot.correlation <- function(feature, responses, data, cor.pvs, xlab="expression", ylab="response") {
  ## ensure common samples:
  if ((length(responses) != nrow(data)) || !all(names(responses) == rownames(data))) {
    inter <- intersect.samples(responses, data)
    responses <- inter$responses
    data <- inter$data
  }
  ## if only one value and no name, assume Pearson correlation:
  if ((length(cor.pvs) == 1) && is.null(names(cor.pvs))) names(cor.pvs) <- "cor.pearson"
  cors <- cor.pvs[grep("^cor\\.", names(cor.pvs))]
  methods <- sub("^cor\\.", "", names(cors))
  labels <- sapply(seq_along(methods), function(i) {
    if (methods[i] == "pearson") {
      paste("r ==", format(cor.pvs[i], digits=2))
    } else if (methods[i] == "spearman") {
      paste("rho ==", format(cor.pvs[i], digits=2))
    }
  })
  ## p-value included?
  p.index <- grep("^p\\.", names(cor.pvs))
  if (length(p.index) > 0) {
    labels <- c(labels, paste("p ==", format(cor.pvs[p.index[1]], digits=2)))
  }
  labels <- paste0("list(", paste(labels, collapse=", "), ")")
  if (!is.null(dim(data))) data <- data[, feature] # vector or matrix/data frame given?
  plot(data, responses, main=paste0(feature, "\n"), xlab=xlab, ylab=ylab)
  mtext(parse(text=labels), adj=0.5, cex=par("cex"))
}


#' Generate multiple scatter plots from correlation results
#'
#' Each plot in the array is generated by [plot.correlation()].
#'
#' @param cor.pvs Named vector or matrix of correlation coefficients (and pvalues, optionally)
#' @param responses Vector of response values (shown on y axis)
#' @param data Matrix of feature values (shown on x axis)
#' @param which Indexes selecting which results (features) to plot
#' @param rows Number of rows of plots
#' @param title Plot title (default: automatically generated)
#' @param xlab X axis label
#' @param ylab Y axis label
plot.correlations <- function(cor.pvs, responses, data, which=1:10, rows=2,
                              title=NULL, xlab="expression", ylab="response") {
  if (is.null(dim(cor.pvs))) cor.pvs <- as.matrix(cor.pvs, ncol=1)
  ## check that values in `which` are valid indexes:
  valid <- intersect(1:nrow(cor.pvs), which)
  if (length(valid) == 0) stop("No valid entries in 'which'")
  if (length(valid) != length(which)) warning("Not all entries in 'which' are valid")

  old.par <- par(mfrow=c(rows, ceiling(length(valid) / rows)),
                 mar=c(3, 3, 3, 1) + 0.1, oma=c(2, 2, 2, 0))
  on.exit(par(old.par))
  for (i in valid) {
    feature <- rownames(cor.pvs)[i]
    plot.correlation(feature, responses, data, cor.pvs[i, ], "", "")
  }
  if (is.null(title)) title <- paste("Correlating", ylab, "and", xlab)
  old.par <- c(old.par, par(mgp=c(0, 0, 0)))
  title(paste0(title, " (n = ", length(responses), ")"), xlab=xlab, ylab=ylab,
        outer=TRUE, cex.main=1.5, cex.lab=1.5)
}


#' Test for univariate associations using correlations
#'
#' Every column of `data` is compared to `responses`.
#' Strength of association is measured by Spearman and Pearson correlation coefficients, and significance is estimated based on null distributions.
#' If `out.prefix` is not empty, two output files are created by appending ".csv" and ".pdf" to `out.prefix`.
#' The data frame containing results will be stored as a CSV file.
#' If `plot` is TRUE, a PDF file will be generated with the following plots:
#' Distributions of the Spearman/Pearson correlations and null distributions used to estimate p-values (via [plot.correlation.densities()]); scatter plots for the features with highest positive/negative correlations (`plot.cors` features in each case, via [plot.correlations()]).
#'
#' @param responses Named numeric vector of responses (e.g. drug effects, genetic dependencies)
#' @param data Named numeric matrix of feature data (e.g. gene expression)
#' @param out.prefix Path and filename prefix for output files (extension will be appended)
#' @param sample.names Subset of sample names to use
#' @param n.null Number of repeats for null distribution
#' @param plot Create PDF with plots?
#' @param plot.cors Number of top hits (pos./neg. correlations) to plot
#' @param plot.rows Number of rows for arranging plots of top hits
#' @param plot.xlab X axis label for [plot.correlations()] plots
#' @param plot.ylab Y axis label for [plot.correlations()] plots
#' @return Numeric matrix of correlation coefficients and p-values
correlation.analysis <- function(responses, data, out.prefix="", sample.names=NULL,
                                 n.null=10, plot=TRUE, plot.cors=15, plot.rows=3,
                                 plot.xlab="expression", plot.ylab="response") {
  ## match samples:
  if (!is.null(sample.names)) {
    data <- data[rownames(data) %in% sample.names, ]
  }
  if ((length(responses) != nrow(data)) || !all(names(responses) == rownames(data))) {
    inter <- intersect.samples(responses, data)
    responses <- inter$responses
    data <- inter$data
  }

  cor.pvs <- correlations.with.pvalues(responses, data, methods=c("spearman", "pearson"),
                                       n.null=n.null, return.null=plot)
  cor.pvs <- cor.pvs[order(abs(cor.pvs[, "cor.spearman"]), abs(cor.pvs[, "cor.pearson"]), decreasing=TRUE), ]

  ## plot to PDF file:
  if (plot && nchar(out.prefix) > 0) {
    pdf(paste0(out.prefix, ".pdf"), paper="a4r", height=0, width=0)
    on.exit(dev.off())
    plot.correlation.densities(cor.pvs, "spearman")
    plot.correlation.densities(cor.pvs, "pearson")
    if (plot.cors > 0) {
      is.negative <- cor.pvs[, "cor.spearman"] < 0
      plot.correlations(cor.pvs[!is.negative, ], responses, data, 1:plot.cors, plot.rows,
                        "Top positive correlations", xlab=plot.xlab, ylab=plot.ylab)
      plot.correlations(cor.pvs[is.negative, ], responses, data, 1:plot.cors, plot.rows,
                        "Top negative correlations", xlab=plot.xlab, ylab=plot.ylab)
    }
  }

  write.csv(cor.pvs, paste0(out.prefix, ".csv"))
  cor.pvs
}
