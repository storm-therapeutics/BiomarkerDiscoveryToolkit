## Functions for biomarker discovery (e.g. for drug sensitivity in cell lines)
## Here: plotting functions for univariate analyses

#' Generate a scatter plot with annotations
#'
#' The values in `response` are plotted against the values in `data` (`feature` column if `data` is a matrix).
#' `feature` is used as plot title.
#' A subtitle is generated from `cor.pvs`, including Pearson/Spearman correlation coefficients and the first p-value (if available).
#'
#' @param feature Name of the feature shown (e.g. gene)
#' @param responses Response values (shown on y axis)
#' @param data Feature values (vector or matrix; shown on x axis)
#' @param cor.pvs Numeric vector of correlation coefficients (and p-values, optionally)
#' @param xlab X axis label
#' @param ylab Y axis label
#' @param show.n Include number of samples in the annotation?
#' @param labels.cex Scaling factor for sample labels (default: labels not shown)
#' @param ... Further arguments passed to [plot()]
#' @export plot.correlation
plot.correlation <- function(feature, responses, data, cor.pvs, xlab="expression", ylab="response",
                             show.n=FALSE, labels.cex=0, ...) {
  ## ensure common samples:
  if ((length(responses) != nrow(data)) || !all(names(responses) == rownames(data))) {
    inter <- intersect.samples(responses, data)
    responses <- inter$responses
    data <- inter$data
  }
  ## if only one value and no name, assume Pearson correlation:
  if ((length(cor.pvs) == 1) && is.null(names(cor.pvs))) names(cor.pvs) <- "cor.pearson"
  ## 'cor.pvs' should be a vector, but we can also handle a matrix:
  if (!is.null(dim(cor.pvs)) && (feature %in% rownames(cor.pvs))) cor.pvs <- cor.pvs[feature, ]
  cors <- cor.pvs[grep("^cor\\.", names(cor.pvs))]
  if (length(cors) > 0) {
    methods <- sub("^cor\\.", "", names(cors))
  } else {
    methods <- names(cor.pvs) # e.g. result from `compute.correlations`
  }
  subtitle <- sapply(seq_along(methods), function(i) {
    if (methods[i] == "pearson") {
      paste("r ==", format(cor.pvs[i], digits=2))
    } else if (methods[i] == "spearman") {
      paste("rho ==", format(cor.pvs[i], digits=2))
    }
  })
  ## p-value included?
  p.index <- grep("^p\\.", names(cor.pvs))
  if (length(p.index) > 0) {
    subtitle <- c(subtitle, paste("p ==", format(cor.pvs[p.index[1]], digits=2)))
  }
  ## show number of samples?
  if (show.n) subtitle <- c(subtitle, paste("n ==", length(responses)))

  subtitle <- paste0("list(", paste(subtitle, collapse=", "), ")")
  if (!is.null(dim(data)) && (ncol(data) > 1)) data <- data[, feature] # vector or matrix/data frame given?
  plot(data, responses, main=paste0(feature, "\n"), xlab=xlab, ylab=ylab, ...)
  grid()
  mtext(parse(text=subtitle), adj=0.5, cex=par("cex"))
  if (labels.cex > 0) {
    text(data, responses, names(responses), pos=ifelse(data > mean(range(data, na.rm=TRUE)), 2, 4), cex=labels.cex)
  }
}


#' Generate multiple scatter plots from correlation results
#'
#' Each plot in the array is generated by [plot.correlation()].
#'
#' @param cor.pvs Named vector or matrix of correlation coefficients (and pvalues, optionally)
#' @param responses Vector of response values (shown on y axis)
#' @param data Matrix of feature values (shown on x axis)
#' @param which Indexes selecting which results (features) to plot
#' @param rows Number of rows of plots
#' @param title Plot title (default: automatically generated)
#' @param xlab X axis label
#' @param ylab Y axis label
#' @param ... Further arguments passed to [plot.correlation()]
#' @export plot.correlations
plot.correlations <- function(cor.pvs, responses, data, which=1:10, rows=2,
                              title=NULL, xlab="expression", ylab="response", ...) {
  if (is.null(dim(cor.pvs))) cor.pvs <- as.matrix(cor.pvs, ncol=1)
  ## check that values in `which` are valid indexes:
  valid <- intersect(1:nrow(cor.pvs), which)
  if (length(valid) == 0) stop("No valid entries in 'which'")
  if (length(valid) != length(which)) warning("Not all entries in 'which' are valid")

  old.par <- par(mfrow=c(rows, ceiling(length(valid) / rows)),
                 mar=c(3, 3, 3, 1) + 0.1, oma=c(2, 2, 2, 0))
  on.exit(par(old.par))
  for (i in valid) {
    feature <- rownames(cor.pvs)[i]
    plot.correlation(feature, responses, data, cor.pvs[i, ], "", "", ...)
  }
  if (is.null(title)) title <- paste("Correlating", ylab, "and", xlab)
  old.par <- c(old.par, par(mgp=c(0, 0, 0)))
  if (title != "") {
    n.samples <- length(intersect(names(responses), rownames(data)))
    title <- paste0(title, " (n = ", n.samples, ")")
  }
  title(title, xlab=xlab, ylab=ylab, outer=TRUE, cex.main=1.5, cex.lab=1.5)
}


#' Generate boxplots comparing groups of numeric data
#'
#' Generate one boxplot per level of `responses`.
#' Each shows the distribution of corresponding values for `feature` in `data`.
#'
#' @param feature Feature (column in `data`) to plot
#' @param responses Vector of categorical responses (factor)
#' @param data  Named numeric matrix of feature data (e.g. gene expression)
#' @param stats Test statistics as returned by [group.analysis()] or [DESeq2::results()]
#' @param xlab X axis label
#' @param ylab Y axis label
#' @param ... Further arguments passed to [ggpubr::ggboxplot()]
#' @return Boxplot object
#' @export plot.group
plot.group <- function(feature, responses, data, stats=NULL, xlab="", ylab="expression", ...) {
  ## ensure common samples:
  if ((length(responses) != nrow(data)) || !all(names(responses) == rownames(data))) {
    inter <- intersect.samples(responses, data)
    responses <- inter$responses
    data <- inter$data
  }
  if (isTRUE(nrow(stats) > 1)) stats <- stats[feature, ]
  plot.data <- data.frame(response=responses, data=data[, feature])
  if (!is.null(stats)) {
    ## check different versions of column names:
    pvalue.col <- grep("^p([-_\\.]?value)?$", names(stats))
    qvalue.col <- grep("^((p[-_\\.]?adj)|q)$", names(stats))
    lfc.col <- grep("^(LFC|log2FoldChange)$", names(stats), ignore.case=TRUE)
    subtitle <- paste0("p: ", format(stats[[pvalue.col[1]]], digits=2))
    if (length(qvalue.col) > 0) {
      subtitle <- paste0(subtitle, ", q: ", format(stats[[qvalue.col[1]]], digits=2))
    }
    if (length(lfc.col) > 0) {
      subtitle <- paste0(subtitle, ", LFC: ", format(stats[[lfc.col[1]]], digits=2))
    }
  } else subtitle <- ""

  grayColor<- brewer.pal(5, "RdGy")[c(1,5)]

  ggpubr::ggboxplot(plot.data, x="response", y="data", add="jitter",
                    add.params=list(alpha=0.2), legend="none", ...) +
    labs(x=xlab, y=ylab, title=feature, subtitle=subtitle)+scale_colour_manual(values=grayColor)
}


#' Generate multiple sets of boxplots comparing groups of numeric data
#'
#' Each plot is generated by [plot.group()].
#'
#' @param stats Test statistics as returned by [group.analysis()] or [DESeq2::results()]
#' @param responses Vector of categorical responses (factor)
#' @param data Named numeric matrix of feature data (e.g. gene expression)
#' @param which Indexes or names selecting which results (features) to plot
#' @param rows Number of rows of plots
#' @param title Plot title
#' @param xlab X axis label
#' @param ylab Y axis label
#' @param ... Further arguments passed to [plot.group()]
#' @return Plot object
#' @export plot.groups
plot.groups <- function(stats, responses, data, which=1:10, rows=2, title=NULL,
                        xlab=NULL, ylab="expression", ...) {
  ## check that values in `which` are valid row names or indexes:
  if (is.character(which)) valid <- rownames(stats) else valid <- 1:nrow(stats)
  valid <- intersect(which, valid)
  if (length(valid) == 0) stop("No valid entries in 'which'")
  if (length(valid) != length(which)) warning("Not all entries in 'which' are valid")

  plots <- lapply(valid, function(feature) {
    if (!is.character(feature)) feature <- rownames(stats)[feature] # index given
    plot.group(feature, responses, data, stats, xlab="", ylab="", ...)
  })
  plot <- ggpubr::ggarrange(plotlist=plots, nrow=rows, ncol=ceiling(length(plots) / rows))
  ggpubr::annotate_figure(plot, top=ggpubr::text_grob(title, face="bold"),
                          left=ggpubr::text_grob(ylab, rot=90), bottom=ggpubr::text_grob(xlab))
}


#' Plot Cox model predictions for low/high feature values
#'
#' The names of the `quantiles` parameter are used in the figure legend
#'
#' @param model Univariate Cox regression model (`coxph` object)
#' @param data Data used to generate `model`
#' @param base.curve Observed survival curve for comparison with predictions (`survfit` object)
#' @param quantiles Quantiles of feature values in `data` to use for prediction and plotting
#' @param xlab X axis label for plots
#' @param ylab Y axis label for plots
#' @export plot.cox.pred
plot.cox.pred <- function(model, data, base.curve=NULL, quantiles=c(low=0.25, high=0.75),
                          xlab="Time", ylab="Fraction surviving") {
  feature <- names(coef(model))
  values <- data.frame(quantile(data[, feature], quantiles))
  names(values) <- feature
  cols <- if (nrow(values) == 2) c(4, 2) else (1:nrow(values)) + 1
  plot(survival::survfit(model, newdata=values), col=cols, lwd=2,
       xlab=xlab, ylab=ylab, main=paste("Cox regression using", feature))
  grid()
  labels <- paste0("Model: ", feature, " ", names(quantiles), " (", quantiles * 100, "%)")
  if (!is.null(base.curve)) {
    lines(base.curve, mark.time=TRUE, conf.int=FALSE)
    labels <- c("Observed data", labels)
    cols <- c(1, cols)
    lwds <- c(1, rep(2, nrow(values)))
  } else lwds <- 2
  legend("topright", labels, col=cols, lty=1, bg="white", lwd=lwds)
  pvalue <- coef(summary(model))[1, 5]
  subtitle <- paste("Significance of", feature, "model coefficient: p =", format(pvalue, digits=2))
  mtext(subtitle, line=0.25)
}
